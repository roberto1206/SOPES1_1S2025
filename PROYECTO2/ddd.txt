este es el archivo main de rust
use actix_web::{post, web, App, HttpServer, Responder, HttpResponse};
use serde::{Deserialize, Serialize};
use reqwest::Client;
use std::env;

#[derive(Deserialize, Serialize)]
struct WeatherData {
    description: String,
    country: String,
    weather: String,
}

#[post("/input")]
async fn receive_weather(data: web::Json<WeatherData>) -> impl Responder {
    let client = Client::new();

    // Obtiene la URL del servicio Go desde una variable de entorno
    // o usa un valor predeterminado para pruebas locales
    let go_service_url = env::var("GO_SERVICE_URL")
    .unwrap_or_else(|_| "http://grpc-client-service:8081/input".to_string());
    
    println!("Enviando datos a: {}", go_service_url);

    // Para pruebas independientes, puedes desactivar el reenvío si está configurado
    if env::var("SKIP_FORWARDING").is_ok() {
        return HttpResponse::Ok().body("Datos recibidos (modo prueba local)");
    }

    // Envía la información al servicio Go
    let res = client.post(go_service_url)
        .json(&*data)
        .send()
        .await;

    match res {
        Ok(_) => HttpResponse::Ok().body("Weather data forwarded!"),
        Err(e) => {
            eprintln!("Error sending to Go service: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to forward weather data")
        }
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    println!("Iniciando API Rust en 0.0.0.0:8080");
    HttpServer::new(|| {
        App::new()
            .service(receive_weather)
    })
    .bind(("0.0.0.0", 8080))?
    .run()
    .await
}

este es el Dockerfile
# Etapa de compilación
FROM rust:latest AS builder

WORKDIR /usr/src/app
COPY . .

# Compilamos la aplicación
RUN cargo build --release

# Etapa de ejecución
FROM debian:bookworm-slim

# Instalamos las dependencias necesarias para runtime
RUN apt-get update && \
    apt-get install -y --no-install-recommends ca-certificates libssl-dev && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app
# Copiamos el binario desde la etapa de construcción
COPY --from=builder /usr/src/app/target/release/api_rust .

# Exponemos el puerto que utiliza la aplicación
EXPOSE 8080

# Ejecutamos la aplicación
CMD ["./api_rust"]

Dockerfile en grpc_client
FROM golang:1.24.2 AS builder

WORKDIR /app
COPY . .
RUN go mod tidy
RUN CGO_ENABLED=0 GOOS=linux go build -o app

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY --from=builder /app/app .
EXPOSE 8081
CMD ["./app"]

grpc_client.go
package main

import (
	"context"
	"time"

	pb "grpc_client/proto" // cambia según tu estructura

	"google.golang.org/grpc"
)

func sendToGRPCServer(data *pb.WeatherData, address string) error {
	conn, err := grpc.Dial(address, grpc.WithInsecure())
	if err != nil {
		return err
	}
	defer conn.Close()

	client := pb.NewWeatherServiceClient(conn)

	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	_, err = client.SendWeather(ctx, data)
	if err != nil {
		return err
	}

	return nil
}

main.go
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"

	pb "grpc_client/proto"
)

func handler(w http.ResponseWriter, r *http.Request) {
	var weather pb.WeatherData

	err := json.NewDecoder(r.Body).Decode(&weather)
	if err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// Obtener direcciones de los servidores gRPC de variables de entorno
	rabbitServer := os.Getenv("RABBIT_SERVER")
	if rabbitServer == "" {
		rabbitServer = "localhost:50051"
	}

	kafkaServer := os.Getenv("KAFKA_SERVER")
	if kafkaServer == "" {
		kafkaServer = "localhost:50052"
	}

	// log.Printf("Recibido: %v - Reenviando a RabbitMQ(%s) y Kafka(%s)", weather, rabbitServer, kafkaServer)

	go func() {
		err := sendToGRPCServer(&weather, rabbitServer)
		if err != nil {
			log.Println("Error enviando a servidor gRPC RabbitMQ:", err)
		} else {
			log.Println("Datos enviados correctamente a RabbitMQ")
		}

		err = sendToGRPCServer(&weather, kafkaServer)
		if err != nil {
			log.Println("Error enviando a servidor gRPC Kafka:", err)
		} else {
			log.Println("Datos enviados correctamente a Kafka")
		}
	}()

	w.WriteHeader(http.StatusOK)
	w.Write([]byte("Datos meteorológicos recibidos y reenviados"))
}

func main() {
	// Usar puerto 8081 para no colisionar con la API Rust que usa 8080
	port := "8081"

	http.HandleFunc("/input", handler)
	log.Printf("Cliente API REST ejecutándose en puerto :%s", port)
	http.ListenAndServe(":"+port, nil)
}
